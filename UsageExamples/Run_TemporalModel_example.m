%% Example: Using TemporalModel for bidirectional lag regression
%
% This script demonstrates how to use TemporalModel.m to fit a bidirectional
% temporal lag model relating behavioral predictors (e.g., face motion) to
% neural ROI activity.
%
% Prerequisites:
%   1. Run rois_to_mat.m to generate ROI.mat from your imaging data
%   2. Ensure ridgeMML.m is on your MATLAB path
%
% Author: Generated by Claude Code
% Date: 2025

clear; clc;

%% 1. Load ROI data
% Replace this path with your actual ROI.mat file
roi_file = 'path/to/your/ROI.mat';

if ~exist(roi_file, 'file')
    error(['ROI file not found: %s\n' ...
           'Please run rois_to_mat.m first to generate ROI.mat'], roi_file);
end

fprintf('Loading ROI data from:\n  %s\n\n', roi_file);
ROI = load(roi_file);

% If the .mat file contains a struct named 'ROI', extract it
if isfield(ROI, 'ROI')
    ROI = ROI.ROI;
end

%% 2. Inspect available ROIs
fprintf('=== Available ROIs ===\n');
fprintf('Fluorescence ROIs (%d):\n', length(ROI.modalities.fluorescence.labels));
for i = 1:length(ROI.modalities.fluorescence.labels)
    fprintf('  %d. %s\n', i, ROI.modalities.fluorescence.labels{i});
end

fprintf('\nBehavioral predictors (%d):\n', length(ROI.modalities.behavior.labels));
for i = 1:length(ROI.modalities.behavior.labels)
    fprintf('  %d. %s\n', i, ROI.modalities.behavior.labels{i});
end
fprintf('\n');

%% 3. Configure model options
opts = struct();

% Select target ROIs
opts.target_neural_roi = 'AU_L';           % Change to your neural ROI name
opts.behavior_predictor = 'Face';          % Change to your behavioral ROI name

% Lag parameters (choose ONE of these two approaches):
% Option A: Specify lags in frames
opts.min_lag = -5;    % Negative = leads (predictive)
opts.max_lag = 10;    % Positive = lags (reactive)

% Option B: Specify lags in seconds (overrides frame-based settings)
% opts.min_lag_seconds = -0.5;    % e.g., -0.5 seconds = fluorescence leads by 500ms
% opts.max_lag_seconds = 1.0;     % e.g., +1.0 seconds = fluorescence lags by 1s

% Cross-validation settings
opts.cv_folds = 5;               % Number of CV folds (more = slower but more robust)

% Output options
opts.save_results = true;        % Save results to .mat file
opts.show_plots = true;          % Generate diagnostic plots
opts.output_file = '';           % Leave empty for auto-generated filename

%% 4. Run temporal model
fprintf('=== Running TemporalModel ===\n');
results = TemporalModel(ROI, opts);

%% 5. Inspect results
fprintf('\n=== Results Summary ===\n');

% Temporal kernel
fprintf('\nTemporal Kernel (CV-averaged):\n');
fprintf('  Peak lag: %.3f s (%d frames)\n', ...
    results.temporal_kernel.peak_lag_sec, ...
    results.temporal_kernel.peak_lag_frames);
fprintf('  Peak beta: %.4f ± %.4f\n', ...
    results.temporal_kernel.peak_beta, ...
    results.temporal_kernel.peak_beta_sem);

if results.temporal_kernel.peak_lag_frames < 0
    fprintf('  → Neural activity PREDICTS future motion (motor planning)\n');
elseif results.temporal_kernel.peak_lag_frames > 0
    fprintf('  → Neural activity FOLLOWS motion (sensory feedback)\n');
else
    fprintf('  → Instantaneous relationship\n');
end

% Performance
fprintf('\nModel Performance:\n');
fprintf('  R² (CV estimate): %.2f%% ± %.2f%%\n', ...
    results.performance.R2_cv_mean * 100, ...
    results.performance.R2_cv_sem * 100);
fprintf('  R² (full-data fit): %.2f%% [optimistic]\n', ...
    results.performance.R2_full_data * 100);

fprintf('\nCV fold R² values:\n');
for fold = 1:length(results.performance.R2_cv_folds)
    fprintf('  Fold %d: %.2f%%\n', fold, results.performance.R2_cv_folds(fold) * 100);
end

%% 6. Additional visualizations (optional)

% Plot beta weights for individual CV folds (optional)
figure('Name', 'CV Fold Comparison');
tk = results.temporal_kernel;

% Plot each fold's beta weights
plot(tk.lag_times_sec, tk.beta_cv_folds, '-', 'Color', [0.7 0.7 0.7], ...
    'HandleVisibility', 'off');
hold on;

% Overlay CV mean
plot(tk.lag_times_sec, tk.beta_cv_mean, 'k-', 'LineWidth', 2, ...
    'DisplayName', 'CV mean');

% Overlay CV mean ± SEM
plot(tk.lag_times_sec, tk.beta_cv_mean + tk.beta_cv_sem, 'k--', ...
    'LineWidth', 1, 'DisplayName', 'CV mean ± SEM');
plot(tk.lag_times_sec, tk.beta_cv_mean - tk.beta_cv_sem, 'k--', ...
    'LineWidth', 1, 'HandleVisibility', 'off');

hold off;
xlabel('Lag time (seconds)');
ylabel('Beta coefficient');
title('Temporal Kernel Across CV Folds');
legend('Location', 'best');
grid on;

% Plot R² across CV folds
figure('Name', 'CV Fold Performance');
bar(results.performance.R2_cv_folds * 100);
hold on;
yline(results.performance.R2_cv_mean * 100, 'r--', 'LineWidth', 2, ...
    'DisplayName', sprintf('Mean: %.2f%%', results.performance.R2_cv_mean * 100));
hold off;
xlabel('CV Fold');
ylabel('R² (%)');
title('Model Performance Across CV Folds');
legend('Location', 'best');
grid on;

fprintf('\n=== Analysis complete ===\n');

%% 7. Tips for interpretation

% TIP 1: Cross-validation R² is the honest estimate
%   - Use R2_cv_mean for reporting model performance
%   - R2_full_data is typically higher (overfitting on training data)

% TIP 2: Temporal kernel uncertainty
%   - beta_cv_sem tells you which lags are reliably non-zero
%   - If beta_cv_sem is large relative to beta_cv_mean, that lag is uncertain

% TIP 3: Peak lag interpretation
%   - Negative peak lag = neural activity predicts future motion
%   - Positive peak lag = neural activity follows motion
%   - Consider biological plausibility (e.g., hemodynamic delay ~2-4s)

% TIP 4: If R² is low (<10%)
%   - Try different lag ranges (longer window might capture slow dynamics)
%   - Check if ROI extraction worked correctly (plot traces)
%   - Consider if behavior and neural activity are actually coupled
